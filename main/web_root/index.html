<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LED Setup</title>
<!-- Tabulator CDN -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/css/tabulator_simple.min.css" rel="stylesheet">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/js/tabulator.min.js"></script>
<!-- flatpickr CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<!-- moment.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.27.0/moment.min.js"></script>
<!-- tingle.js CDN -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-colorschemes@0.4.0/dist/chartjs-plugin-colorschemes.min.js"></script>

<!-- Local stylesheet for customizing modal -->
<link rel="stylesheet" href="modal.css">
<style>
  html {font-family: sans-serif; scroll-behavior: smooth;}
  body {margin: .5rem 0;}
  h1, h2, h3, h4 { font-weight: 500; margin-top: 0;}

  .container {margin: 1rem 0;}
  .space_evenly {display: flex; justify-content: space-evenly;}
  .flex_end {display: flex; justify-content: flex-end; }
  .chart {position: relative; height: 33vh;}

  .tabulator-col-title {text-align: center;}
  #timerTable {width:40%; margin-right:5%}
  #channelTable {width:60%}
  #scheduleTable {width: 100%;}
  
  .page {
    margin-left: 15vw;
    margin-right: 5vw; 
    min-height:calc(100vh - 1rem);
    margin-bottom: 1rem;
  }

  #sidebar {
  position: fixed;
  top: 0;
  left: 0;

  height: 100%;
  width: 10vw;
  
  background-color: #e4e3e3;
  overflow-x: hidden;
  }

  #sidebar a {
    display: block;
    padding: .5rem 1rem;
    text-decoration: none;
    color: black;
    transition-duration: 0.2s;
  }

  #sidebar a:hover:not(.active) {
    background-color:#546A76;
    color: white;
  }

  #footer {
    position: fixed;
    bottom: 0;
    left: 0;

    width: calc(100% - 20vw);
    height: 5vh;
    min-height: 2.5rem;
    margin-left: 10vw;
    padding-left: 5vw;
    padding-right: 5vw;

    background-color: #88A0A8;
    z-index: 1;
    display: flex;
    justify-content: flex-end;
    align-items: center;
  }

  #status {
    flex-grow: 1;
    font-size: larger;
  }

  button {
    border: none;
    color: white;
    background-color:dimgray;
    transition-duration: 0.2s;
    cursor:pointer;
    border-radius: 4px;
  }

  #footer button {
    padding: .5rem 1.5rem;
    margin-left: 1rem;
    font-size: 1rem;
  }

  button.good:hover {
    background-color: mediumseagreen;
  }

  button.danger:hover {
    background-color: lightcoral;
  }

  button:hover {
    background-color: lightsteelblue;
  }

  .page button {
    padding: .5rem .5rem;
  }

  .page form {
    margin-left: 15%;
    margin-right: 15%;
    display: grid;
    grid-template-columns: 1fr 2fr;
    grid-row-gap: .75rem;
    align-items: center; 
  }

  .page form > label {
    grid-column: 1 / 2;
  }

  .page form > input {
    grid-column: 2 / 3;
  }
</style>
</head>

<body>
<div id="sidebar">
  <a href="#schedule">Schedule</a>
  <a href="#configure">Channel Setup</a>
  <a href="#system">System Settings</a>
</div>

<div id="footer">
  <span id="status"></span>
  <button class="danger" onclick="load()">Reset</button>
  <button class="good" onclick="save()">Save</button>
</div>

<div class="page">
  <a id="schedule"><h2>Schedule</h2></a>

  <div class="container chart">
    <canvas id="scheduleChart"></canvas>
  </div>

  <div class="container flex_end">
  <button onclick="scheduleTable.addRow()">Add Time</button>
  </div>

  <div class="container">
    <div id="scheduleTable"></div>
  </div>
</div>

<div class="page">
  <a id="configure"><h2>Channel Setup</h2></a>

  <div class="container space_evenly">
    <div id="timerTable"></div>
    <div id="channelTable"></div>
  </div>
</div>

<div class="page">
  <a id="system"><h2>System Settings</h2></a>
  <form class="container">
    <label for="hostname">Hostname</label>
    <input type="text" id="hostname"/>

    <label for="timezone">Timezone</label>
    <input type="text" id="timezone"/>
    
    <label for="ntp_server_1">NTP Server 1</label>
    <input type="text" id="ntp_server_1"/>
    <label for="ntp_server_2">NTP Server 2</label>
    <input type="text" id="ntp_server_2"/>
  </form>
</div>

<div id="modal" class="tingle-modal modal-content">
<div class="modal-header">
<h2>Add Sweep</h2>
</div>
<form id="modal-form">
  <label for="startTime">Start Time</label>
  <input class="time-picker" type="time" id="startTime" required/>

  <label for="startIntensity">Start Intensity</label>
  <input id="startIntensity" type="number" min="0" max="100" required/>

  <label for="endTime">End Time</label>
  <input class="time-picker" type="time" id="endTime" required/>

  <label for="endIntensity">End Intensity</label>
  <input id="endIntensity" type="number" min="0" max="100" required/>

  <label for="mode-group">Mode</label>
  <div class="radio-group" id="mode-group">
    <input type="radio" name="mode" id="cubic"  value="cubic" checked><label for="cubic">Cubic</label>
    <input type="radio" name="mode" id="linear" value="linear"><label for="linear">Linear</label>
  </div>
  
  <label for="step-group">Step Type</label>
  <div class="radio-group" id="step-group">
    <input type="radio" name="stepMode" id="time" value="time" onchange='document.getElementById("stepLabel").innerHTML="Minutes Per"' checked><label for="time">Time</label>
    <input type="radio" name="stepMode" id="count" value="count" onchange='document.getElementById("stepLabel").innerHTML="Step Count"'><label for="count">Count</label>
  </div>

  <label id="stepLabel" for="step">Minutes Per</label>
  <input id="step" type="number" min="1" max ="120" value="10" required/>
</form>
</div>
<script src="index.js"></script>
<script type="text/javascript">
// Define the system config table
var timerTable = new Tabulator("#timerTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Timers.all,
  layout: "fitColumns",
  columns: [
    { title: "Timer", field: "name", widthGrow:3, },
    { title: "Frequency", field: "freq", widthGrow:2, editor: "number", 
      editorParams: {
        min: 0, 
        max: 50000, 
        step:1000, 
        mask: "99999",
      },
      validator:"max:50000",
      tooltip: (c) => !c.isValid() ? "Frequency value must be between 0 Hz and 50 kHz." : "",
    },
  ],
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});

function generateSweep(e, column)
{
  modal.open_with_promise().then((formData) => {
    // Check the channel ID of the column selected
    let id = column.getField();

    // Get start and end TODs as moment objects
    let startT = moment(formData.startTime.value, "HH:mm");
    let endT = moment(formData.endTime.value, "HH:mm");
    
    // Calculate the time delta in minutes, and desired step size
    let deltaT = moment.duration(endT - startT).asMinutes();
    let step = 0;
    switch (formData.stepMode.value)
    {
      case "time":
        step = parseInt(formData.step.value);
        break;

      case "count":
        step = deltaT / parseInt(formData.step.value);
        break;
    }

    // Calculate the intensity delta
    let startI = parseInt(formData.startIntensity.value);
    let endI = parseInt(formData.endIntensity.value);
    let deltaI = endI - startI;

    // Select the interpolation function
    let interpolate = formData.mode.value == "cubic" ? cubic_interpolate : linear_interpolate;

    let newRows = [];
    let stepT = startT;
    for (t of range(0, deltaT, step)) {
      
      let stepY = interpolate(deltaI, t/deltaT)

      row = {}
      row["tod"] = stepT.format("HH:mm");
      row[id] = Math.round(startI + stepY);

      newRows.push(row);

      stepT = stepT.add(step, "minutes")
    }

    // Add and resort table
    scheduleTable.updateOrAddData(newRows);
    scheduleTable.setSort("tod", "asc");
  });
}

// Define the channel table
var channelTable = new Tabulator("#channelTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Channels.all,
  layout: "fitColumns",
  columns: [
    { title: "ID", field: "id"},
    { title: "Name", field: "name", widthGrow:3, editor: "input", },
    { title: "Timer", field: "timer", widthGrow:2, editor: "select", 
      editorParams:{ 
        values:() => Timers.select_list,
        listItemFormatter:(v,t) => Timers.get_name(v),
      }, 
      formatter: (c, p, o) => Timers.get_name(c.getValue()),
    },
    { title: "GPIO", field: "gpio", editor: "number", editorParams: { min: 0, max: 31, mask: "99" }, validator: ["unique", "max:31"], 
        cellEdited: (c) => { if (!c.getData().valid) c.getRow().getCell("enabled").setValue(false) },
        tooltip: (c) => !c.isValid() ? "GPIO value must be unique and between 0-31" : "",
    },
    { title: "Enabled", field: "enabled", formatter: "tickCross", hozAlign: "center",
        cellClick: (e, c) => { if (c.getData().valid) c.setValue(!c.getValue()) },
        tooltip: (c) => !c.getData().valid ? "GPIO must be assigned to enable channel." : "",
    }
  ],
  dataEdited: () => scheduleTable.setColumns(columnTemplate.concat(Channels.columns)), // Trigger schedule column update whenever this table is changed
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});

// Template for first 2 columns of schedule table
var columnTemplate = [
  { title: "Remove", formatter: "buttonCross", hozAlign: "center", cellClick: (e, cell) => cell.getRow().delete() },
  { title: "Time Of Day", field: "tod", editor: timeEditor, headerSort: true, sorter: "time", validator: ["unique", "required"],
    cellEdited: (c) => c.getColumn().validate(),
    tooltip: (c) => !c.isValid() ? "Time Of Day must be set and unique." : "",
    sorterParams: {
      format: "HH:mm",
      alignEmptyValues: "bottom",
    }
  },
];

var scheduleTable = new Tabulator("#scheduleTable", {
  headerSort: false,
  // reactiveData doesn't appear to work if columns are variable
  //reactiveData: true,
  data: Schedule.data,
  layout:"fitDataFill",
  columns: columnTemplate,
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
  index:"tod",
  dataEdited: updateScheduleData,
  dataLoaded: updateScheduleData,
});

window.onload = () => load();

// Add a function which opens the Modal and returns a promise to be resolved on close
tingle.modal.prototype.open_with_promise = function ()
{
  let promise = new Promise((resolve, reject) => {
    this.promise_resolve = resolve;
    this.promise_reject = reject;
    this.open();
  });

  return promise;
}

// Create the modal object
var modal = new tingle.modal({
  footer: true,
  closeMethods: ["overlay", "escape"],
  closeLabel: "Close",
  onOpen: () => {
    // Attach timepickr to our time inputs
    document.querySelectorAll(".time-picker").forEach((p) => {
      let picker = flatpickr(p, {
        enableTime: true,
        noCalendar: true,
        dateFormat: "H:i",
        defaultDate: p.value,
      });
    });
  },
});

// Close and resolve promise if form is OK
modal.addFooterBtn("OK", "tingle-btn tingle-btn--pull-right", () => {
  if (document.getElementById("modal-form").reportValidity())
  {
    modal.promise_resolve(document.getElementById("modal-form").elements);
    modal.close();
  }
});

// Close and reject promise
modal.addFooterBtn("Cancel", "tingle-btn tingle-btn--pull-right", () => {
  modal.promise_reject();
  modal.close();
});

// Set the content
modal.setContent(document.querySelector(".modal-content").innerHTML);
 // Remove the HTML from the DOM so ids are unique
document.querySelector(".modal-content").innerHTML = ""

var context = document.getElementById("scheduleChart").getContext("2d");
var chart = new Chart(context, {
  type: "line",
  options: {
    responsive: true,
    maintainAspectRatio: false,
    datasets: {
      line: {
        steppedLine: "before",
        fill: false,
      },
    },
    scales: {
      xAxes: [{
        type: "time",
        time: {
          parser: "HH:mm",
          minUnit: "hour",
        },
        ticks: {
          min: "00:00",
          max: "24:00",
        },
      }],
      yAxes: [{
        ticks: {
          min: 0,
          max: 100,
        },
      }],
    },
    tooltips: {
      position: "nearest",
      mode: "index",
    },
    plugins: {
      colorschemes: {
        scheme: "brewer.Accent8"
      }
    }
  }
});
</script>
</body>
</html>