<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LED Setup</title>
<!-- Tabulator CDN -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/css/tabulator_simple.min.css" rel="stylesheet">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/js/tabulator.min.js"></script>
<!-- flatpickr CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<!-- moment.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.27.0/moment.min.js"></script>
<!-- tingle.js CDN -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js"></script>

<!-- Local stylesheet for customizing modal -->
<link rel="stylesheet" href="modal.css">
<style>
  html {font-family: sans-serif;}
  body {margin-left: 5vw; margin-right: 5vw;}
  .tabulator-col-title {text-align: center;}
  .container {display: flex; width:auto; justify-content: space-evenly;}
  #timerTable {width:40%; margin-right:5%}
  #channelTable {width:60%}
  #scheduleTable {width: 100%;}
</style>
</head>

<body>
<div class="container">
<div id="timerTable"></div><div id="channelTable"></div>
</div>

<div class="container"></div>
<button onclick="scheduleTable.addRow()">Add Time</button>
<button onclick="save()">Save</button>
<span id="status"></span>
</div>

<div class="container">
<div id="scheduleTable"></div>
</div>

<div id="modal" class="tingle-modal modal-content">
<div class="modal-header">
<h2>Add Sweep</h2>
</div>
<form id="modal-form">
  <label for="startTime">Start Time</label>
  <input class="time-picker" type="time" id="startTime" required/>

  <label for="startIntensity">Start Intensity</label>
  <input id="startIntensity" type="number" min="0" max="100" required/>

  <label for="endTime">End Time</label>
  <input class="time-picker" type="time" id="endTime" required/>

  <label for="endIntensity">End Intensity</label>
  <input id="endIntensity" type="number" min="0" max="100" required/>

  <label for="mode-group">Mode</label>
  <div class="radio-group" id="mode-group">
    <input type="radio" name="mode" id="cubic"  value="cubic" checked><label for="cubic">Cubic</label>
    <input type="radio" name="mode" id="linear" value="linear"><label for="linear">Linear</label>
  </div>
  
  <label for="step-group">Step Type</label>
  <div class="radio-group" id="step-group">
    <input type="radio" name="stepMode" id="time" value="time" onchange='document.getElementById("stepLabel").innerHTML="Minutes Per"' checked><label for="time">Time</label>
    <input type="radio" name="stepMode" id="count" value="count" onchange='document.getElementById("stepLabel").innerHTML="Step Count"'><label for="count">Count</label>
  </div>

  <label id="stepLabel" for="step">Minutes Per</label>
  <input id="step" type="number" min="1" max ="120" value="10" required/>
</form>
</div>
<script src="index.js"></script>
<script type="text/javascript">
// Define the system config table
var timerTable = new Tabulator("#timerTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Timers.all,
  layout: "fitColumns",
  columns: [
    { title: "Timer", field: "name", widthGrow:3, },
    { title: "Frequency", field: "freq", widthGrow:2, editor: "number", 
      editorParams: {
        min: 0, 
        max: 50000, 
        step:1000, 
        mask: "99999",
      },
      validator:"max:50000",
      tooltip: (c) => !c.isValid() ? "Frequency value must be between 0 Hz and 50 kHz." : "",
    },
  ],
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});

function generateSweep(e, column)
{
  modal.open_with_promise().then((formData) => {
    // Check the channel ID of the column selected
    let id = column.getField();

    // Get start and end TODs as moment objects
    let startT = moment(formData.startTime.value, "HH:mm");
    let endT = moment(formData.endTime.value, "HH:mm");
    
    // Calculate the time delta in minutes, and desired step size
    let deltaT = moment.duration(endT - startT).asMinutes();
    let step = 0;
    switch (formData.stepMode.value)
    {
      case "time":
        step = parseInt(formData.step.value);
        break;

      case "count":
        step = deltaT / parseInt(formData.step.value);
        break;
    }

    // Calculate the intensity delta
    let startI = parseInt(formData.startIntensity.value);
    let endI = parseInt(formData.endIntensity.value);
    let deltaI = endI - startI;

    // Select the interpolation function
    let interpolate = formData.mode.value == "cubic" ? cubic_interpolate : linear_interpolate;

    let newRows = [];
    let stepT = startT;
    for (t of range(0, deltaT, step)) {
      
      let stepY = interpolate(deltaI, t/deltaT)

      row = {}
      row["tod"] = stepT.format("HH:mm");
      row[id] = Math.round(startI + stepY);

      newRows.push(row);

      stepT = stepT.add(step, "minutes")
    }

    // Add and resort table
    scheduleTable.updateOrAddData(newRows);
    scheduleTable.setSort("tod", "asc");
  });
}

// Define the channel table
var channelTable = new Tabulator("#channelTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Channels.all,
  layout: "fitColumns",
  columns: [
    { title: "ID", field: "id"},
    { title: "Name", field: "name", widthGrow:3, editor: "input", },
    { title: "Timer", field: "timer", widthGrow:2, editor: "select", 
      editorParams:{ 
        values:() => Timers.select_list,
        listItemFormatter:(v,t) => Timers.get_name(v),
      }, 
      formatter: (c, p, o) => Timers.get_name(c.getValue()),
    },
    { title: "GPIO", field: "gpio", editor: "number", editorParams: { min: 0, max: 31, mask: "99" }, validator: ["unique", "max:31"], 
        cellEdited: (c) => { if (!c.getData().valid) c.getRow().getCell("enabled").setValue(false) },
        tooltip: (c) => !c.isValid() ? "GPIO value must be unique and between 0-31" : "",
    },
    { title: "Enabled", field: "enabled", formatter: "tickCross", hozAlign: "center",
        cellClick: (e, c) => { if (c.getData().valid) c.setValue(!c.getValue()) },
        tooltip: (c) => !c.getData().valid ? "GPIO must be assigned to enable channel." : "",
    }
  ],
  dataEdited: () => scheduleTable.setColumns(columnTemplate.concat(Channels.columns)), // Trigger schedule column update whenever this table is changed
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});

// Template for first 2 columns of schedule table
var columnTemplate = [
  { title: "Remove", formatter: "buttonCross", hozAlign: "center", cellClick: (e, cell) => cell.getRow().delete() },
  { title: "Time Of Day", field: "tod", editor: timeEditor, headerSort: true, sorter: "time", validator: ["unique", "required"],
    cellEdited: (c) => c.getColumn().validate(),
    tooltip: (c) => !c.isValid() ? "Time Of Day must be set and unique." : "",
    sorterParams: {
      format: "HH:mm",
      alignEmptyValues: "bottom",
    }
  },
];

var scheduleTable = new Tabulator("#scheduleTable", {
  headerSort: false,
  // reactiveData doesn't appear to work if columns are variable
  //reactiveData: true,
  data: Schedule.data,
  layout:"fitDataFill",
  columns: columnTemplate,
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
  movableRows: true,
  index:"tod",
});

window.onload = () => load();

// Add a function which opens the Modal and returns a promise to be resolved on close
tingle.modal.prototype.open_with_promise = function ()
{
  let promise = new Promise((resolve, reject) => {
    this.promise_resolve = resolve;
    this.promise_reject = reject;
    this.open();
  });

  return promise;
}

// Create the modal object
var modal = new tingle.modal({
  footer: true,
  closeMethods: ["overlay", "escape"],
  closeLabel: "Close",
  onOpen: () => {
    // Attach timepickr to our time inputs
    document.querySelectorAll(".time-picker").forEach((p) => {
      let picker = flatpickr(p, {
        enableTime: true,
        noCalendar: true,
        dateFormat: "H:i",
        defaultDate: p.value,
      });
    });
  },
});

// Close and resolve promise if form is OK
modal.addFooterBtn("OK", "tingle-btn tingle-btn--pull-right", () => {
  if (document.getElementById("modal-form").reportValidity())
  {
    modal.promise_resolve(document.getElementById("modal-form").elements);
    modal.close();
  }
});

// Close and reject promise
modal.addFooterBtn("Cancel", "tingle-btn tingle-btn--pull-right", () => {
  modal.promise_reject();
  modal.close();
});

// Set the content
modal.setContent(document.querySelector(".modal-content").innerHTML);
 // Remove the HTML from the DOM so ids are unique
document.querySelector(".modal-content").innerHTML = ""
</script>
</body>
</html>