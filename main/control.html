<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LED Setup</title>
<style>
.tabulator-col-title {  text-align: center;}
.container {display: flex; width:auto; justify-content: space-evenly; padding-left:5%; padding-right:5%}
#timerTable {width:40%; margin-right:5%}
#channelTable {width:60%}
#scheduleTable {width: 100%;}
</style>
<!-- Tabulator CDN -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/css/tabulator_simple.min.css" rel="stylesheet">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/tabulator/4.7.1/js/tabulator.min.js"></script>
<!-- flatpickr CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<!-- moment.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.27.0/moment.min.js"></script>
</head>
<body>
<div class="container">
<div id="timerTable"></div><div id="channelTable"></div>
</div>
<br/>
<div class="container"></div>
<button onclick="scheduleTable.addRow()">Add Time</button>
<button onclick="save()">Save</button>
<span id="status"></span>
</div>
<br/>
<div class="container">
<div id="scheduleTable"></div>
</div>
<script type="text/javascript">
// Workaround issue #2858 https://github.com/olifolkerd/tabulator/issues/2858
Tabulator.prototype.moduleBindings.edit.prototype.clearEdited = function (cell) {
  if (cell.modules.edit && cell.modules.edit.edited) {
    if (cell.modules.validate && cell.modules.validate.invalid) {
      cell.modules.validate.invalid = false;
    }

    let editIndex = this.editedCells.indexOf(cell);

    if (editIndex > -1) {
      this.editedCells.splice(editIndex, 1);
    }
  }
};

// Class to represent a timer configuration
class Timer {
  constructor(index) {
    this.id = index;
    this.name = "Timer " + index;
    this.freq = 120;
    this.enabled = false;
  }

  get valid() { return this.freq ? true : false; }
}

// "Namespace" to handle timer array
var Timers = {
  _timers: Array.from(Array(4).keys()).map(x => new Timer(x)),
  
  get all() {
    return this._timers;
  },

  get enabled() {
    return this._timers.filter(t => t.enabled);
  },

  get select_list() {
    return [""].concat(Timers.enabled.map(t => t.id));
  },

  get_name: function(id) {
    return id !== "" ? this._timers[id].name : "";
  },

  get dictionary() {
    // Fetch the timer table as a dictionary
    let obj = {};
    this.all.forEach(t => obj[t.id] = t);
    return obj;
  },
}

// Define the system config table
var timerTable = new Tabulator("#timerTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Timers.all,
  layout: "fitColumns",
  columns: [
    { title: "Timer", field: "name", widthGrow:3, },
    { title: "Frequency", field: "freq", widthGrow:2, editor: "number", 
      editorParams: {
        min: 0, 
        max: 50000, 
        step:1000, 
        mask: "99999",
      },
      validator:"max:50000",
      cellEdited: (c) => { if (!c.getData().valid) c.getRow().getCell("enabled").setValue(false) },
      tooltip: (c) => !c.isValid() ? "Frequency value must be between 0 Hz and 50 kHz." : "",
    },
    { title: "Enabled", field: "enabled", formatter: "tickCross", hozAlign: "center",
        cellClick: (e, c) => { if (c.getData().valid) c.setValue(!c.getValue()) },
        tooltip: (c) => !c.getData().valid ? "Frequency must be assigned to enable timer." : "",
    }
  ],
  dataEdited: () => channelTable.getColumn("timer").validate(),
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});


// Class to represent a channel configuration
class Channel {
  constructor(index) {
    this.id = index;
    this.name = "Channel " + index;
    this.timer = "";
    this.gpio = null;
    this.enabled = false;
  }

  get columnDefinition() {
    // Generate a Tabulator column def
    return {
      title: "Channel " + this.id + "<br/>" + this.name,
      field: "" + this.id, // int -> string
      editor: "number", editorParams: { min: 0, max: 100, step: 10, mask: "999" },
      validator: "max:100",
      hozAlign: "center",
      minWidth:"100em"
    };
  }

  get valid() { return this.gpio && this.timer >= 0; }
}

// "Namespace" to handle channel array
var Channels = {
  _channels: Array.from(Array(8).keys()).map(x => new Channel(x)),
  
  get all() {
    return this._channels;
  },

  get enabled() {
    return this._channels.filter(c => c.enabled);
  },

  get columns() {
    return this.enabled.map(c => c.columnDefinition);
  },

  get dictionary() {
    let obj = {};
    this.all.forEach(c => obj[c.id] = c);
    return obj;
  },
}

// Define the channel table
var channelTable = new Tabulator("#channelTable", {
  headerSort: false, // Don't allow sorting
  reactiveData: true, // Update data source as table is editted
  data: Channels.all,
  layout: "fitColumns",
  columns: [
    { title: "ID", field: "id"},
    { title: "Name", field: "name", widthGrow:3, editor: "input", },
    { title: "Timer", field: "timer", widthGrow:2, editor: "select", 
      editorParams:{ 
        values:() => Timers.select_list,
        listItemFormatter:(v,t) => Timers.get_name(v),
      }, 
      formatter: (c, p, o) => Timers.get_name(c.getValue()),
      validator: (c,v,p) => Timers.select_list.includes(v),
      cellEdited: (c) => { if (!c.getData().valid) c.getRow().getCell("enabled").setValue(false) },
      tooltip: (c) => !c.isValid() ? "Selected timer must be enabled." : "",
    },
    { title: "GPIO", field: "gpio", editor: "number", editorParams: { min: 0, max: 31, mask: "99" }, validator: ["unique", "max:31"], 
        cellEdited: (c) => { if (!c.getData().valid) c.getRow().getCell("enabled").setValue(false) },
        tooltip: (c) => !c.isValid() ? "GPIO value must be unique and between 0-31" : "",
    },
    { title: "Enabled", field: "enabled", formatter: "tickCross", hozAlign: "center",
        cellClick: (e, c) => { if (c.getData().valid) c.setValue(!c.getValue()) },
        tooltip: (c) => !c.getData().valid ? "GPIO and timer must be assigned to enable channel." : "",
    }
  ],
  dataEdited: () => scheduleTable.setColumns(columnTemplate.concat(Channels.columns)), // Trigger schedule column update whenever this table is changed
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
});

var schedule = [];

function timeEditor(cell, onRendered, success, cancel, editorParams) {
  let editor = document.createElement("input");

  editor.setAttribute("id", "timepicker");
  editor.setAttribute("type", "time");

  onRendered(function () {
    // Attach a time picker tothe editor
    let picker = flatpickr("#" + editor.id, {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      defaultDate: cell.getValue(),
      onClose: () => success(editor.value),
    });

    // Open the editor
    picker.open();
  });

  return editor;
}

// Template for first 2 columns of schedule table
var columnTemplate = [
  { title: "Remove", formatter: "buttonCross", hozAlign: "center", cellClick: (e, cell) => cell.getRow().delete() },
  { title: "Time Of Day", field: "tod", editor: timeEditor, headerSort: true, sorter: "time", validator: ["unique", "required"],
    cellEdited: (c) => c.getColumn().validate(),
    tooltip: (c) => !c.isValid() ? "Time Of Day must be set and unique." : "",
    sorterParams: {
      format: "HH:mm",
      alignEmptyValues: "bottom",
    }
  },
];

var scheduleTable = new Tabulator("#scheduleTable", {
  headerSort: false,
  reactiveData: true, // Update data source as table is editted
  data: schedule,
  layout:"fitDataFill",
  columns: columnTemplate,
  validationMode: "highlight",
  tooltipGenerationMode: "hover",
  movableRows: true,
});


var Status = {
  _element: document.getElementById("status"),

  set: function (message) {
    this._element.innerHTML = message;
  },

  set_success: function (message) {
    this.set(message);
  },

  set_error: function (message) {
    this.set("Save failed: " + message);
  },
}

function sendJsonXhrRequest(json, callback) {
  if (typeof josn != "string")
    json = JSON.stringify(json);

  let xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == XMLHttpRequest.DONE) {
      callback(xhr.status)
    }
  };

  xhr.open("POST", window.location.href + "/?action=set");
  xhr.timeout = 5000;
  xhr.setRequestHeader("Content-Type", "application/json");
  xhr.send(json);
}

function save() {
  if (timerTable.getInvalidCells().length)
  {
    Status.set_error("Invalid timer setup. Please fix errors.");
    return;
  }

  if (channelTable.getInvalidCells().length)
  {
    Status.set_error("Invalid channel setup. Please fix errors.");
    return;
  }

  if (scheduleTable.getInvalidCells().length)
  {
    Status.set_error("Invalid schedule. Please fix errors.");
    return;
  }

  let settings = {};
  settings.timers = Timers.dictionary;
  settings.channels = Channels.dictionary;
  settings.schedule = scheduleTable.getData();

  console.log("Timers:" + JSON.stringify(settings.timers));
  console.log("Channels:" + JSON.stringify(settings.channels));
  console.log("Schedule:" + JSON.stringify(settings.schedule));

  function setCallback(status) {
    if (status == 200)
      Status.set_success("Complete.");
    else {
      message = "Failed. Error: ";
      message += (status != 0) ? xhr.responseText : "Timeout";
      Status.set_error(message);
    }
  }

  Status.set("Sending data...");
  sendJsonXhrRequest(settings, setCallback);
}
</script>
</body>
</html>